RAII 全称就Resource acquisition is initialization. 意为资源获取要通过构造函数初始化，然后析构函数负责释放资源。
大部分时候又被用于做Scope Guard，Scope Guard同lambda服用，效果更佳，见下文。

RAII替我们实现了”某个操作在任何分支结束的时候，会被执行，且被执行一次“。而利用这个保证，我们可以不再那么麻烦和痛苦的叮嘱自己一定要记得释放内存，
一定不要释放两次及以上。而任何需要这个效果的都可以而且也推荐使用RAII来实现，不要依赖程序员的自觉和认真！

为了充分利用右值的资源，减少不必要的拷贝，C++11引入了右值引用(&&)，移动构造函数，移动复制运算符以及std::move。
在没有右值引用之前，为了使用临时变量，通常定义const的左值引用，比如const string&，
在有了右值引用之后，为了使用右值语义，不要把参数定义为常量左值引用，否则，传递右值时调用的时拷贝构造函数

在C++11中，标准库在中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，
继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);

std::move实现：
1. 首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过T&&传递类型保持不变还是右值，而左值经过T&&变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。（cpr:先能够把参数类型全都接收）
2. 然后我们通过static_cast<>进行强制类型转换返回T&&右值引用，而static_cast之所以能使用类型转换，是通过remove_refrence::type模板移除T&&，T&的引用，获取具体类型T（模板偏特化）。（cpr:再把接收的参数的原引用抹除强转成右引）
————————————————
版权声明：本文为CSDN博主「子木呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41687938/article/details/119797468
